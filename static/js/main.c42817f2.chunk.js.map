{"version":3,"sources":["webcam.js","controller_dataset.js","component1.js","App.js","serviceWorker.js","index.js","logo.svg"],"names":["Webcam","webcamElement","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","_this2","tf","webcamImage","croppedImage","cropImage","batchedImage","expandDims","dispose","toFloat","div","sub","img","size","Math","min","shape","beginHeight","beginWidth","slice","width","height","aspectRatio","Promise","resolve","reject","navigatorAny","navigator","getUserMedia","webkitGetUserMedia","mozGetUserMedia","msGetUserMedia","video","stream","_this3","srcObject","addEventListener","asyncToGenerator","regenerator_default","a","mark","_callee","wrap","_context","prev","next","adjustVideoSize","videoWidth","videoHeight","stop","error","Component","ControllerDataset","numClasses","example","label","y","console","log","xs","ys","oldX","concat","oldY","elem","document","getElementById","parentNode","removeChild","createElement","setAttribute","body","appendChild","style","marginBottom","infoText","innerText","Comp","props","react_default","className","onLoad","main","src","logo","alt","id","controls","autoPlay","App","state","predd","mobilenet","model","NUM_CLASSES","webcam","controllerDataset","loadMobilenet","_loadMobilenet","apply","arguments","layer","sent","getLayer","abrupt","inputs","outputs","output","_init","_callee2","button1","button2","button3","main0","_context2","capture","addExample","predict","setup","_train","_callee4","optimizer","batchSize","_context4","alert","Error","layers","flatten","inputShape","dense","units","activation","kernelInitializer","useBias","adam","compile","loss","floor","fit","epochs","callbacks","onBatchEnd","_onBatchEnd","_callee3","batch","logs","_context3","toFixed","_x","_x2","_predict","_callee5","predictedClass","classId","prob","_context5","as1D","argMax","data","dataSync","init","train","window","location","reload","component1","reset","Boolean","hostname","match","ReactDOM","render","src_App_0","serviceWorker","ready","then","registration","unregister","module","exports","__webpack_require__","p"],"mappings":"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","file":"static/js/main.c42817f2.chunk.js","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n \nimport { Component } from 'react';\nimport * as tf from '@tensorflow/tfjs';\n\n\n\n\n/**\n * A class that wraps webcam video elements to capture Tensor4Ds.\n */\n\n class Webcam extends Component {\n\n  /**\n   * @param {HTMLVideoElement} webcamElement A HTMLVideoElement representing the webcam feed.\n   */\n  constructor(webcamElement) {\n    super();\n    this.webcamElement = webcamElement;\n  }\n\n  /**\n   * Captures a frame from the webcam and normalizes it between -1 and 1.\n   * Returns a batched image (1-element batch) of shape [1, w, h, c].\n   */\n capture() {\n    return tf.tidy(() => {\n      // Reads the image as a Tensor from the webcam <video> element.\n      const webcamImage = tf.fromPixels(this.webcamElement);\n\n      // Crop the image so we're using the center square of the rectangular\n      // webcam.\n      const croppedImage = this.cropImage(webcamImage);\n\n      // Expand the outer most dimension so we have a batch size of 1.\n      const batchedImage = croppedImage.expandDims(0);\n\n      webcamImage.dispose();\n      croppedImage.dispose();\n\n      // Normalize the image between -1 and 1. The image comes in between 0-255,\n      // so we divide by 127 and subtract 1.\n      return batchedImage.toFloat().div(tf.scalar(127)).sub(tf.scalar(1));\n    });\n  }\n\n  /**\n   * Crops an image tensor so we get a square image with no white space.\n   * @param {Tensor4D} img An input image Tensor to crop.\n   */\n  cropImage(img) {\n    const size = Math.min(img.shape[0], img.shape[1]);\n    const centerHeight = img.shape[0] / 2;\n    const beginHeight = centerHeight - (size / 2);\n    const centerWidth = img.shape[1] / 2;\n    const beginWidth = centerWidth - (size / 2);\n    return img.slice([beginHeight, beginWidth, 0], [size, size, 3]);\n  }\n\n  /**\n   * Adjusts the video size so we can make a centered square crop without\n   * including whitespace.\n   * @param {number} width The real width of the video element.\n   * @param {number} height The real height of the video element.\n   */\n  adjustVideoSize(width, height) {\n    const aspectRatio = width / height;\n    if (width >= height) {\n      this.webcamElement.width = aspectRatio * this.webcamElement.height;\n    } else if (width < height) {\n      this.webcamElement.height = this.webcamElement.width / aspectRatio;\n    }\n  }\n\n  async setup() {\n    return new Promise((resolve, reject) => {\n      const navigatorAny = navigator;\n      navigator.getUserMedia = navigator.getUserMedia ||\n          navigatorAny.webkitGetUserMedia || navigatorAny.mozGetUserMedia ||\n          navigatorAny.msGetUserMedia;\n      if (navigator.getUserMedia) {\n        navigator.getUserMedia(\n            {video: true},\n            stream => {\n              this.webcamElement.srcObject = stream;\n              this.webcamElement.addEventListener('loadeddata', async () => {\n                this.adjustVideoSize(\n                    this.webcamElement.videoWidth,\n                    this.webcamElement.videoHeight);\n                resolve();\n              }, false);\n            },\n            error => {\n              reject();\n            });\n      } else {\n        reject();\n      }\n    });\n  }\n}\n\nexport default Webcam;\n","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport { Component } from 'react';\nimport * as tf from '@tensorflow/tfjs';\n\n/**\n * A dataset for webcam controls which allows the user to add example Tensors\n * for particular labels. This object will concat them into two large xs and ys.\n */\nclass ControllerDataset extends Component {\n\n  constructor(numClasses) {\n    super();\n    this.numClasses = numClasses;\n  }\n\n\n\n  /**\n   * Adds an example to the controller dataset.\n   * @param {Tensor} example A tensor representing the example. It can be an image,\n   *     an activation, or any other type of Tensor.\n   * @param {number} label The label of the example. Should be an umber.\n   */\n  addExample(example, label) {\n\n\n    // One-hot encode the label.\n\n    const y = tf.tidy(() => tf.oneHot(tf.tensor1d([label], 'int32'), this.numClasses));\n    console.log(\"label:\",label);\n\n\n    if (this.xs == null) {\n      // For the first example that gets added, keep example and y so that the\n      // ControllerDataset owns the memory of the inputs. This makes sure that\n      // if addExample() is called in a tf.tidy(), these Tensors will not get\n      // disposed.\n      this.xs = tf.keep(example);\n      this.ys = tf.keep(y);\n    } else {\n      const oldX = this.xs;\n      this.xs = tf.keep(oldX.concat(example, 0));\n\n      const oldY = this.ys;\n      this.ys = tf.keep(oldY.concat(y, 0));\n\n      oldX.dispose();\n      oldY.dispose();\n      y.dispose();\n\n      //console.log(label, this.ys.toString());\n\n\n            const elem = document.getElementById(\"Div1\");\n            \n            if (elem !== null){\n            elem.parentNode.removeChild(elem);\n          }\n\n            const div = document.createElement('div');\n            div.setAttribute(\"id\", \"Div1\");\n            document.body.appendChild(div);\n            div.style.marginBottom = '10px';\n            // Create info text\n\n\n            const infoText = document.createElement('span')\n            infoText.innerText = (`EXAMPLE #  ${this.ys.shape[0]} ADDED`);\n            div.appendChild(infoText);\n\n            //const elem1 = document.getElementById(\"Div1\");\n            \n            \n            //elem1.parentNode.removeChild(elem1);\n          \n\n\n\n\n\n    }\n  }\n}\n\nexport default ControllerDataset;","import React from 'react';\nimport logo from './logo.svg';\nimport './App.css';\n\n\nconst Comp = (props) => (\n\n  <div >\n\n\n    <div className=\"App\" onLoad = {props.main}>\n      <header className=\"App-header\" >\n        <img src={logo} className=\"App-logo\" alt=\"logo\" /> \n        <h4 className=\"App-title\">Webcam classifier with Tensorflow.js and REACT</h4>\n      </header>     \n    </div> \n\n\n    <div id=\"message\">\n       <p>To capture images for every class, press CLASS 0-2 respectively. \n       Afterwars press TRAIN, and finally PREDICT.</p>\n    </div>\n\n\n    <div id=\"webcam-wrapper\" >\n    <video id=\"webcam\"  width=\"224\" height=\"224\" controls autoPlay ></video><br/>\n\n\n    <br/><button id=\"1\" > Class 0 </button>\n    <button id=\"2\" > Class 1 </button>\n    <button id=\"3\" > Class 2 </button><br/>\n\n   <br/> <button  id=\"train\" > TRAIN </button>\n    <button  id=\"predict\" > PREDICT </button>\n    <button  id=\"reset\"> RESET </button> \n\n  </div><br/>\n\n</div>\n);\n\nexport default Comp;\n","import React, { Component } from 'react';\nimport './App.css';\nimport Webcam from './webcam';\nimport ControllerDataset from './controller_dataset.js';\nimport * as tf from '@tensorflow/tfjs';\nimport Comp from './component1';\n\n\nclass App extends Component {\n\n\n\nstate = {\n      predd:[],\n    }\n\n  main = () => {\n\n\n    let mobilenet;\n    let model;\n    //let predd = [];\n\n\n\n    const NUM_CLASSES = 3;\n    const webcam = new Webcam(document.getElementById('webcam'));\n    const controllerDataset = new ControllerDataset(NUM_CLASSES);\n\n    // Loads mobilenet and returns a model that returns the internal activation\n    // we'll use as input to our classifier model.\n    async function loadMobilenet() {\n      const mobilenet = await tf.loadModel(\n          'https://storage.googleapis.com/tfjs-models/tfjs/mobilenet_v1_0.25_224/model.json');\n\n      // Return a model that outputs an internal activation.\n      const layer = mobilenet.getLayer('conv_pw_13_relu');\n      return tf.model({inputs: mobilenet.inputs, outputs: layer.output});\n    }\n\n\n    // When the UI buttons are pressed, read a frame from the webcam and associate\n    // it with the class label given by the button. up, down, left, right are\n    // labels 0, 1, 2, 3 respectively.\n\n\n    async function init() {\n\n      await webcam.setup();\n      mobilenet = await loadMobilenet();\n\n      // Warm up the model. This uploads weights to the GPU and compiles the WebGL\n      // programs so the first time we collect data from the webcam it will be\n      // quick.\n\n      tf.tidy(() => mobilenet.predict(webcam.capture()));\n\n      const img = webcam.capture();\n\n\n            // Listen for mouse events when clicking the button\n            //button.addEventListener('mousedown', () => training = 10);\n            //button.addEventListener('mouseup', () => training = -1);\n\n\n      const button1 = document.getElementById('1');\n            button1.addEventListener('mousedown', () => main0(0));\n            button1.addEventListener('mouseup', () => main0(0));\n\n      const button2 = document.getElementById('2');\n            button2.addEventListener('mousedown', () => main0(1));\n            button2.addEventListener('mouseup', () => main0(1));\n\n       const button3 = document.getElementById('3');\n             button3.addEventListener('mousedown', () => main0(2));\n             button3.addEventListener('mouseup', () => main0(2));     \n\n\n            \n      function  main0 (label) {\n          \n      // When the UI buttons are pressed, read a frame from the webcam and associate\n      // it with the class label given by the button. up, down, left, right are\n      // labels 0, 1, 2, 3 respectively.\n\n          tf.tidy(() => {\n            const img = webcam.capture();\n            controllerDataset.addExample(mobilenet.predict(img), label);\n\n          });\n        }\n\n    }\n\n    // Initialize the application.\n    init();\n\n\n\n    const button4 = document.getElementById('train');\n          button4.addEventListener('click', () => train());\n\n\n    async function train() {\n\n    console.log(\"TRAINN\");\n\n      if (controllerDataset.xs == null) {\n        alert('Add some examples before training!');\n        throw new Error('Add some examples before training!');\n      }\n\n      // Creates a 2-layer fully connected model. By creating a separate model,\n      // rather than adding layers to the mobilenet model, we \"freeze\" the weights\n      // of the mobilenet model, and only train weights from the new model.\n      model = tf.sequential({\n        layers: [\n          // Flattens the input to a vector so we can use it in a dense layer. While\n          // technically a layer, this only performs a reshape (and has no training\n          // parameters).\n          tf.layers.flatten({inputShape: [7, 7, 256]}),\n          // Layer 1\n          tf.layers.dense({\n            units: 100,\n            activation: 'relu',\n            kernelInitializer: 'varianceScaling',\n            useBias: true\n          }),\n          // Layer 2. The number of units of the last layer should correspond\n          // to the number of classes we want to predict.\n          tf.layers.dense({\n            units: NUM_CLASSES,\n            kernelInitializer: 'varianceScaling',\n            useBias: false,\n            activation: 'softmax'\n          })\n        ]\n      });\n\n      // Creates the optimizers which drives training of the model.\n      const optimizer = tf.train.adam(0.0001);\n      // We use categoricalCrossentropy which is the loss function we use for\n      // categorical classification which measures the error between our predicted\n      // probability distribution over classes (probability that an input is of each\n      // class), versus the label (100% probability in the true class)>\n      model.compile({optimizer: optimizer, loss: 'categoricalCrossentropy'});\n\n      // We parameterize batch size as a fraction of the entire dataset because the\n      // number of examples that are collected depends on how many examples the user\n      // collects. This allows us to have a flexible batch size.\n      const batchSize =\n          Math.floor(controllerDataset.xs.shape[0] *0.4);\n      if (!(batchSize > 0)) {\n        throw new Error(\n            `Batch size is 0 or NaN. Please choose a non-zero fraction.`);\n      }\n\n      // Train the model! Model.fit() will shuffle xs & ys so we don't have to.\n      model.fit(controllerDataset.xs, controllerDataset.ys, {\n        batchSize,\n        epochs: 20,\n        callbacks: {\n          onBatchEnd: async (batch, logs) => {\n            console.log('Loss: ' + logs.loss.toFixed(10));\n\n\n            const elem = document.getElementById(\"Div1\");\n            \n            if (elem !== null){\n            elem.parentNode.removeChild(elem);\n          }\n\n            const div = document.createElement('div');\n            div.setAttribute(\"id\", \"Div1\");\n            document.body.appendChild(div);\n            div.style.marginBottom = '10px';\n            // Create info text\n\n\n            const infoText = document.createElement('span')\n            infoText.innerText = (`LOSS: ${logs.loss.toFixed(5)}`);\n            div.appendChild(infoText);\n\n\n\n            await tf.nextFrame();\n          }\n        }\n      });\n\n\n\n    }\n\n\n\n    const button5 = document.getElementById('predict');\n          button5.addEventListener('click', () => predict());\n\n\n\n    \n    async function predict() {\n\n\n    while (true) {\n\n      const predictedClass = tf.tidy(() => {\n        // Capture the frame from the webcam.\n        const img = webcam.capture();\n\n        // Make a prediction through mobilenet, getting the internal activation of\n        // the mobilenet model.\n        const activation = mobilenet.predict(img);\n\n        // Make a prediction through our newly-trained model using the activation\n        // from mobilenet as input.\n        const predictions = model.predict(activation);\n\n        // Returns the index with the maximum probability. This number corresponds\n        // to the class the model thinks is the most probable given the input.\n        //return predictions.as1D().argMax();\n        return predictions.as1D();\n      });\n\n      const classId = (await (predictedClass.argMax()).data())[0];\n\n      const prob = (await (predictedClass.dataSync())[classId]);\n\n      console.log(\"classId:\", classId);\n      console.log(\"prob:\", prob);\n\n\n        const elem = document.getElementById(\"Div1\");\n        \n        if (elem !== null){\n        elem.parentNode.removeChild(elem);\n      }\n\n        const div = document.createElement('div');\n        div.setAttribute(\"id\", \"Div1\");\n        document.body.appendChild(div);\n        div.style.marginBottom = '10px';\n        // Create info text\n\n\n        const infoText = document.createElement('span')\n        infoText.innerText = (`THE PREDICTED CLASS: ${classId} with prob. ${(prob*100).toFixed(0)}%`);\n        div.appendChild(infoText);\n\n\n\n      await tf.nextFrame();\n    \n\n      }\n\n    }\n\n\n     function reset () {\n       window.location.reload();\n            }  \n\n        const button6 = document.getElementById('reset');\n        button6.addEventListener('click', () => reset());\n\n\n\n  }\n\n\n\n  render() {\n\n\n        return (\n                 <Comp\n                 main = {this.main}\n                 reset = {this.reset}\n\n                 />\n      \n       );\n    }\n \n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";"],"sourceRoot":""}